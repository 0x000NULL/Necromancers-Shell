# Necromancer's Shell - Makefile
# C11 standard, ncurses-based terminal game

# Compiler and flags
CC := gcc
CFLAGS := -std=c11 -Wall -Wextra -Werror -pedantic
INCLUDES := -Isrc

# Platform detection and library configuration
UNAME_S := $(shell uname -s 2>/dev/null || echo Windows)

ifeq ($(UNAME_S),Darwin)
    # macOS: Use Homebrew ncurses
    PLATFORM := MACOS
    NCURSES_PREFIX := $(shell brew --prefix ncurses 2>/dev/null || echo "/usr/local/opt/ncurses")
    INCLUDES += -I$(NCURSES_PREFIX)/include
    LIBS := -L$(NCURSES_PREFIX)/lib -lncurses -lm
else ifeq ($(UNAME_S),Linux)
    # Linux: Use system ncurses
    PLATFORM := LINUX
    LIBS := -lncurses -lm
else
    # Windows: Use PDCurses
    PLATFORM := WINDOWS

    # Check if we're in MSYS2/MinGW environment
    ifdef MSYSTEM
        # MSYS2/MinGW environment (GitHub Actions or local MSYS2)
        # PDCurses should be installed via: pacman -S mingw-w64-ucrt-x86_64-pdcurses
        LIBS := -lpdcurses -lm
    else
        # Native Windows build (standalone MinGW or MSVC)
        # User must have PDCurses installed manually
        PDCURSES_PATH ?= C:/pdcurses
        INCLUDES += -I$(PDCURSES_PATH)/include
        LIBS := -L$(PDCURSES_PATH)/lib -lpdcurses
        # Note: Math library is built-in on Windows, -lm may not be needed
    endif
endif

# Directories
SRC_DIR := src
BUILD_DIR := build
TEST_DIR := tests

# Version management
VERSION_FILE := VERSION
VERSION_HEADER := $(SRC_DIR)/core/version_info.h

# Read version from file
VERSION := $(shell cat $(VERSION_FILE) 2>/dev/null || echo "0.0.0")
VERSION_PARTS := $(subst ., ,$(VERSION))
VERSION_MAJOR := $(word 1,$(VERSION_PARTS))
VERSION_MINOR := $(word 2,$(VERSION_PARTS))
VERSION_PATCH := $(word 3,$(VERSION_PARTS))

# Build metadata
BUILD_DATE := $(shell date +%Y-%m-%d)
GIT_HASH := $(shell git rev-parse --short HEAD 2>/dev/null || echo "unknown")

# Source files (auto-detected)
CORE_SRC := $(wildcard $(SRC_DIR)/core/*.c)
TERM_SRC := $(wildcard $(SRC_DIR)/terminal/*.c)
UTIL_SRC := $(wildcard $(SRC_DIR)/utils/*.c)
CMD_SRC := $(wildcard $(SRC_DIR)/commands/*.c) $(wildcard $(SRC_DIR)/commands/commands/*.c)
DATA_SRC := $(wildcard $(SRC_DIR)/data/*.c)
GAME_SRC := $(wildcard $(SRC_DIR)/game/souls/*.c) $(wildcard $(SRC_DIR)/game/resources/*.c) $(wildcard $(SRC_DIR)/game/world/*.c) $(wildcard $(SRC_DIR)/game/minions/*.c) $(wildcard $(SRC_DIR)/game/progression/*.c) $(wildcard $(SRC_DIR)/game/combat/*.c) $(wildcard $(SRC_DIR)/game/network/*.c) $(wildcard $(SRC_DIR)/game/narrative/*.c) $(wildcard $(SRC_DIR)/game/narrative/memory/*.c) $(wildcard $(SRC_DIR)/game/narrative/npcs/*.c) $(wildcard $(SRC_DIR)/game/narrative/relationships/*.c) $(wildcard $(SRC_DIR)/game/narrative/quests/*.c) $(wildcard $(SRC_DIR)/game/narrative/dialogue/*.c) $(wildcard $(SRC_DIR)/game/narrative/alliances/*.c) $(wildcard $(SRC_DIR)/game/narrative/gods/*.c) $(wildcard $(SRC_DIR)/game/narrative/thessara/*.c) $(wildcard $(SRC_DIR)/game/narrative/trials/*.c) $(wildcard $(SRC_DIR)/game/narrative/endings/*.c) $(wildcard $(SRC_DIR)/game/events/*.c) $(wildcard $(SRC_DIR)/game/endings/*.c) $(wildcard $(SRC_DIR)/game/ui/*.c) $(SRC_DIR)/game/game_state.c $(SRC_DIR)/game/game_globals.c

MAIN_SRC := $(SRC_DIR)/main.c

ALL_SRC := $(CORE_SRC) $(TERM_SRC) $(UTIL_SRC) $(CMD_SRC) $(DATA_SRC) $(GAME_SRC) $(MAIN_SRC)
ALL_OBJ := $(ALL_SRC:$(SRC_DIR)/%.c=$(BUILD_DIR)/%.o)

# Test files
TEST_SRC := $(wildcard $(TEST_DIR)/*.c)
TEST_BIN := $(patsubst $(TEST_DIR)/%.c,$(BUILD_DIR)/test_%,$(TEST_SRC))

# Targets
TARGET := $(BUILD_DIR)/necromancer_shell
TARGET_DEBUG := $(BUILD_DIR)/necromancer_shell_debug

# Default target
.DEFAULT_GOAL := release

# Build modes
.PHONY: all debug release clean test valgrind coverage help version

all: debug release

debug: CFLAGS += -g -O0 -DDEBUG
# Address sanitizers not well-supported on MinGW, skip for Windows
ifneq ($(PLATFORM),WINDOWS)
  debug: CFLAGS += -fsanitize=address -fsanitize=undefined
  debug: LDFLAGS += -fsanitize=address -fsanitize=undefined
endif
debug: $(TARGET_DEBUG)

# Release build (portable, no -march=native for CI compatibility)
# Use -march=native only for local builds (not in CI)
release: CFLAGS += -O2 -DNDEBUG
ifndef CI
  release: CFLAGS += -march=native
endif
release: $(TARGET)

# Main targets
$(TARGET): $(ALL_OBJ)
	@mkdir -p $(@D)
	$(CC) $(LDFLAGS) $^ -o $@ $(LIBS)
	@echo "Built release: $(TARGET)"

$(TARGET_DEBUG): $(ALL_OBJ)
	@mkdir -p $(@D)
	$(CC) $(LDFLAGS) $^ -o $@ $(LIBS)
	@echo "Built debug: $(TARGET_DEBUG)"

# Generate version.h from VERSION file
$(VERSION_HEADER): $(VERSION_FILE)
	@echo "Generating $@..."
	@mkdir -p $(@D)
	@echo "/* Auto-generated by Makefile - DO NOT EDIT */" > $@
	@echo "#ifndef NECROMANCERS_VERSION_INFO_H" >> $@
	@echo "#define NECROMANCERS_VERSION_INFO_H" >> $@
	@echo "" >> $@
	@echo "#define VERSION_MAJOR $(VERSION_MAJOR)" >> $@
	@echo "#define VERSION_MINOR $(VERSION_MINOR)" >> $@
	@echo "#define VERSION_PATCH $(VERSION_PATCH)" >> $@
	@echo "#define VERSION_STRING \"$(VERSION)\"" >> $@
	@echo "#define VERSION_BUILD_DATE \"$(BUILD_DATE)\"" >> $@
	@echo "#define VERSION_GIT_HASH \"$(GIT_HASH)\"" >> $@
	@echo "" >> $@
	@echo "#endif /* NECROMANCERS_VERSION_INFO_H */" >> $@

# Object files (depend on version header)
$(BUILD_DIR)/%.o: $(SRC_DIR)/%.c $(VERSION_HEADER)
	@mkdir -p $(@D)
	$(CC) $(CFLAGS) $(INCLUDES) -c $< -o $@

# Dependency tracking (also depends on version header)
-include $(ALL_OBJ:.o=.d)

$(BUILD_DIR)/%.d: $(SRC_DIR)/%.c $(VERSION_HEADER)
	@mkdir -p $(@D)
	@$(CC) $(CFLAGS) $(INCLUDES) -MM -MT $(BUILD_DIR)/$*.o $< -MF $@

# Tests
test: $(TEST_BIN)
	@echo "Running tests..."
	@for test in $(TEST_BIN); do \
		echo "Running $$test..."; \
		$$test || exit 1; \
	done
	@echo "All tests passed!"

$(BUILD_DIR)/test_%: $(TEST_DIR)/%.c $(filter-out $(BUILD_DIR)/main.o,$(ALL_OBJ))
	@mkdir -p $(@D)
	$(CC) $(CFLAGS) $(INCLUDES) $^ -o $@ $(LIBS)

# Memory checking
valgrind: debug
	valgrind --leak-check=full \
	         --show-leak-kinds=all \
	         --track-origins=yes \
	         --verbose \
	         --log-file=valgrind-out.txt \
	         $(TARGET_DEBUG)
	@echo "Valgrind output written to valgrind-out.txt"

# Code coverage
coverage: CFLAGS += -g -O0 --coverage
coverage: LDFLAGS += --coverage
coverage: clean
	@echo "Building with coverage instrumentation..."
	@$(MAKE) $(TEST_BIN) CFLAGS="$(CFLAGS)" LDFLAGS="$(LDFLAGS)"
	@echo "Running tests to collect coverage data..."
	@for test in $(TEST_BIN); do \
		echo "Running $$test..."; \
		$$test || exit 1; \
	done
	@echo "Generating coverage report..."
	@mkdir -p coverage_html
	@lcov --capture --directory $(BUILD_DIR) --output-file coverage.info --rc branch_coverage=1 --ignore-errors inconsistent,mismatch 2>&1 | grep -v "^lcov: WARNING:" || \
		(echo "lcov not found, using gcov only" && find $(BUILD_DIR) -name "*.gcda" -exec gcov {} \;)
	@if command -v lcov >/dev/null 2>&1 && [ -f coverage.info ]; then \
		lcov --remove coverage.info '/usr/*' '*/tests/*' --output-file coverage.info --rc branch_coverage=1 --ignore-errors inconsistent,unused; \
		lcov --list coverage.info --rc branch_coverage=1 | head -40; \
		if command -v genhtml >/dev/null 2>&1; then \
			genhtml coverage.info --output-directory coverage_html --rc branch_coverage=1 --ignore-errors inconsistent,source 2>&1 | grep -v "^genhtml: WARNING:"; \
			echo ""; \
			echo "========================================"; \
			echo "Coverage report generated!"; \
			echo "HTML report: coverage_html/index.html"; \
			echo ""; \
			echo "View with:"; \
			echo "  xdg-open coverage_html/index.html    # Linux"; \
			echo "  open coverage_html/index.html        # macOS"; \
			echo "  python3 -m http.server -d coverage_html  # Web server"; \
			echo "========================================"; \
		else \
			echo "Install genhtml (part of lcov package) to generate HTML reports"; \
		fi; \
	fi
	@echo ""
	@echo "Run 'python3 scripts/coverage_report.py' for detailed category breakdown"

# Profiling
profile: CFLAGS += -pg
profile: $(TARGET)
	./$(TARGET)
	gprof $(TARGET) gmon.out > profile.txt
	@echo "Profile written to profile.txt"

# Static analysis
analyze:
	cppcheck --enable=all --inconclusive --std=c11 $(SRC_DIR)

# Formatting
format:
	find $(SRC_DIR) $(TEST_DIR) -name "*.c" -o -name "*.h" | xargs clang-format -i

# Clean
clean:
	rm -rf $(BUILD_DIR)
	rm -f $(VERSION_HEADER)
	rm -f valgrind-out.txt gmon.out profile.txt
	rm -f coverage.info
	rm -rf coverage_html
	find . -name "*.gcov" -delete 2>/dev/null || true
	find . -name "*.gcda" -delete 2>/dev/null || true
	find . -name "*.gcno" -delete 2>/dev/null || true
ifeq ($(PLATFORM),WINDOWS)
	rm -f *.exe
endif

# Version display
version:
	@echo "Necromancer's Shell v$(VERSION)"
	@echo "  Platform: $(PLATFORM)"
	@echo "  Major: $(VERSION_MAJOR)"
	@echo "  Minor: $(VERSION_MINOR)"
	@echo "  Patch: $(VERSION_PATCH)"
	@echo "  Build Date: $(BUILD_DATE)"
	@echo "  Git Hash: $(GIT_HASH)"

# Help
help:
	@echo "Necromancer's Shell - Build System"
	@echo ""
	@echo "Targets:"
	@echo "  make              - Build release version"
	@echo "  make debug        - Build debug version with sanitizers"
	@echo "  make release      - Build optimized release version"
	@echo "  make test         - Build and run all tests"
	@echo "  make coverage     - Generate code coverage report (requires lcov)"
	@echo "  make valgrind     - Run with valgrind memory checker"
	@echo "  make profile      - Build with profiling, run, and generate profile"
	@echo "  make analyze      - Run static analysis (cppcheck)"
	@echo "  make format       - Format code with clang-format"
	@echo "  make clean        - Remove all build artifacts"
	@echo "  make version      - Display version information"
	@echo "  make help         - Show this help"
ifeq ($(PLATFORM),WINDOWS)
	@echo "  make windows-setup - Show Windows build setup instructions"
endif

# Windows-specific setup instructions
.PHONY: windows-setup
windows-setup:
	@echo "=========================================="
	@echo "Windows Build Setup Instructions"
	@echo "=========================================="
	@echo ""
	@echo "Method 1: MSYS2 (Recommended)"
	@echo "  1. Download and install MSYS2 from: https://www.msys2.org/"
	@echo "  2. Open 'MSYS2 UCRT64' terminal from Start Menu"
	@echo "  3. Install build tools and PDCurses:"
	@echo "     pacman -S mingw-w64-ucrt-x86_64-gcc mingw-w64-ucrt-x86_64-pdcurses make"
	@echo "  4. Navigate to this directory and run: make release"
	@echo ""
	@echo "Method 2: Native MinGW (Advanced)"
	@echo "  1. Install standalone MinGW-w64"
	@echo "  2. Download and build PDCurses from: https://pdcurses.org/"
	@echo "  3. Set PDCURSES_PATH environment variable to PDCurses installation"
	@echo "  4. Run: make release"
	@echo ""
	@echo "For detailed instructions, see WINDOWS_BUILD.md"
	@echo "=========================================="

# Include dependency files
DEPS := $(ALL_OBJ:.o=.d)
-include $(DEPS)
